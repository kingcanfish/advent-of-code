# Day 9: Movie Theater - 详细解题思路

## 目录
1. [问题理解](#问题理解)
2. [Part 1: 最大矩形面积](#part-1-最大矩形面积)
3. [Part 2: 多边形内的最大矩形](#part-2-多边形内的最大矩形)
4. [核心算法详解](#核心算法详解)
5. [代码实现分析](#代码实现分析)
6. [复杂度分析](#复杂度分析)

---

## 问题理解

### 题目背景
我们有一个电影院的地板，上面有许多红色瓷砖。输入是红色瓷砖的坐标列表。

### 输入示例
```
7,1
11,1
11,7
9,7
9,5
2,5
2,3
7,3
```

这代表8个红色瓷砖的位置：`(x, y)` 坐标。

### 可视化
```
..............
.......#...#..  (7,1) 和 (11,1)
..............
..#....#......  (2,3) 和 (7,3)
..............
..#......#....  (2,5) 和 (9,5)
..............
.........#.#..  (9,7) 和 (11,7)
..............
```

其中 `#` 代表红色瓷砖。

---

## Part 1: 最大矩形面积

### 问题描述
选择**任意两个**红色瓷砖作为矩形的对角，找到面积最大的矩形。

### 解题思路

#### 1. 核心概念
- 两个点可以确定一个矩形的对角
- 矩形的边平行于坐标轴
- 面积 = 长 × 宽

#### 2. 计算公式
给定两个点 `p1(x1, y1)` 和 `p2(x2, y2)`：
```
宽度 = |x1 - x2| + 1
高度 = |y1 - y2| + 1
面积 = 宽度 × 高度
```

**为什么要 +1？**
因为瓷砖本身占据一个单位面积。例如：
- 从坐标 2 到坐标 5：|2-5| = 3，但实际包含 2,3,4,5 共4个位置
- 所以需要 +1

#### 3. 算法步骤
```
1. 遍历所有红色瓷砖对 (i, j)，其中 i < j
2. 对每一对，计算它们形成的矩形面积
3. 记录最大面积
4. 返回结果
```

#### 4. 示例演示

**输入点**：`(2,5)` 和 `(11,1)`

**计算过程**：
```
x 坐标范围：2 到 11
  宽度 = |2 - 11| + 1 = 9 + 1 = 10

y 坐标范围：1 到 5
  高度 = |1 - 5| + 1 = 4 + 1 = 5

面积 = 10 × 5 = 50
```

**可视化**：
```
..............
..OOOOOOOOOO..  ← y=1
..OOOOOOOOOO..
..OOOOOOOOOO..
..OOOOOOOOOO..
..OOOOOOOOOO..  ← y=5
..............
  ↑        ↑
 x=2      x=11
```

#### 5. 代码实现
```rust
fn bounding_area(p1: &(i64, i64), p2: &(i64, i64)) -> i64 {
    let dx = (p1.0 - p2.0).abs() + 1;  // 宽度
    let dy = (p1.1 - p2.1).abs() + 1;  // 高度
    dx * dy                             // 面积
}

fn resolve_part1(points: &[(i64, i64)]) -> i64 {
    points
        .iter()
        .enumerate()
        .flat_map(|(i, p1)|
            points[i + 1..].iter()  // 只遍历 i 之后的点，避免重复
                .map(|p2| bounding_area(p1, p2))
        )
        .max()
        .unwrap_or(0)
}
```

#### 6. 时间复杂度
- 遍历所有点对：O(n²)
- 计算面积：O(1)
- **总复杂度：O(n²)**

---

## Part 2: 多边形内的最大矩形

### 问题描述
现在有额外的约束：
1. 红色瓷砖按顺序连接，形成一个**闭合的多边形**
2. 相邻红色瓷砖之间的直线路径是**绿色瓷砖**
3. 多边形**内部**的瓷砖也是**绿色**
4. 矩形必须**完全在绿色+红色区域内**

### 关键理解

#### 1. 多边形的形成
输入的点按顺序连接，最后一个点连回第一个点：
```
点的顺序：(7,1) → (11,1) → (11,7) → (9,7) → (9,5) → (2,5) → (2,3) → (7,3) → (回到7,1)
```

可视化（X 代表绿色瓷砖，# 代表红色瓷砖）：
```
..............
.......#XXX#..  (7,1)→(11,1)
.......X...X..
..#XXXX#...X..  (2,3)→(7,3)  (7,3)到(7,1)
..X........X..
..#XXXXXX#.X..  (2,5)→(9,5)
.........X.X..
.........#X#..  (9,7)
..............
```

#### 2. 什么是"在多边形内"？
一个点在多边形内，当且仅当：
- 在多边形的边界上（红色或绿色瓷砖）
- 在多边形的内部（绿色瓷砖）

### 解题思路

#### 步骤1: 判断点是否在多边形内
使用**射线投射算法**（Ray Casting Algorithm）

**基本原理**：
从测试点向右（或任意方向）发射一条射线，计算射线与多边形边界的交点数量：
- 交点数为**奇数**：点在多边形**内部**
- 交点数为**偶数**：点在多边形**外部**

**图解**：
```
多边形：
    +-------+
    |       |
    |   P1  |射线 →→→→ (交点数=1, 奇数, 在内部)
    |       |
    +-------+

P2 射线 →→→→ (交点数=0, 偶数, 在外部)

        射线
P3 ←←←←|→→→→ (交点数=2, 偶数, 在外部)
       |     |
       +-----+
```

#### 步骤2: 处理特殊情况

**情况1：点在边界上**
直接返回 `true`（边界也算在内）

**情况2：点在顶点上**
直接返回 `true`

**情况3：射线经过顶点**
需要特殊处理，避免重复计数

#### 步骤3: 检查矩形是否完全在多边形内

**方法**：采样检查
1. 检查矩形的**四个角**
2. 沿矩形的**四条边**采样多个点
3. 如果所有采样点都在多边形内，则矩形在内

**为什么需要边缘采样？**
因为多边形可能是**非凸**的（有凹陷）。

例如：
```
+-----+
|     |
|  +--+  ← 凹陷
|  |
+--+

矩形的四个角可能都在内部，但矩形本身可能穿过凹陷的边界！
```

#### 步骤4: 遍历所有红色瓷砖对

```
最大面积 = 0
对于每一对红色瓷砖 (i, j):
    如果它们形成的矩形完全在多边形内:
        计算面积
        更新最大面积
返回最大面积
```

---

## 核心算法详解

### 1. 射线投射算法（Ray Casting）

#### 算法伪代码
```
function point_in_polygon(点P, 多边形polygon):
    inside = false

    对于多边形的每条边 (v1, v2):
        // 检查是否在边界上
        if P 在边上:
            return true

        // 射线投射
        if 射线与边相交:
            inside = NOT inside  // 翻转状态

    return inside
```

#### 详细实现逻辑

**1. 检查是否在顶点上**
```rust
if (x == x1 && y == y1) || (x == x2 && y == y2) {
    return true;
}
```

**2. 检查是否在水平边上**
```rust
if y1 == y2 && y == y1 {  // 边是水平的，且点的y坐标相同
    if x >= x1.min(x2) && x <= x1.max(x2) {  // x在范围内
        return true;
    }
}
```

**3. 检查是否在垂直边上**
```rust
if x1 == x2 && x == x1 {  // 边是垂直的，且点的x坐标相同
    if y >= y1.min(y2) && y <= y1.max(y2) {  // y在范围内
        return true;
    }
}
```

**4. 射线投射检查**
```rust
if (y1 > y) != (y2 > y) {  // 边跨越点的y坐标
    if x1 == x2 {  // 垂直边
        if x < x1 {  // 点在边的左侧
            inside = !inside;  // 翻转状态
        }
    }
}
```

**为什么要检查 `(y1 > y) != (y2 > y)`？**
- 这确保边的两个端点在射线的上下两侧
- 即射线有可能与这条边相交

**为什么 `x < x1` 时翻转？**
- 我们的射线是向右的
- 只有当边在点的右侧时，射线才会与边相交

### 2. 矩形验证算法

#### 采样策略
```rust
let sample_count = 100.min((x2 - x1).max(y2 - y1)) as usize;
```

采样数量取决于矩形的大小：
- 小矩形：采样点数 = 矩形最大边长
- 大矩形：最多采样 100 个点（优化性能）

#### 采样位置
```
+--------+--------+--------+
|                          |  ← 顶边采样
+                          +
|                          |  ← 左右边采样
+                          +
|                          |
+--------+--------+--------+  ← 底边采样
```

**顶边和底边采样**：
```rust
for i in 1..sample_count {
    let x = x1 + (x2 - x1) * i / sample_count;
    检查点 (x, y1) 和 (x, y2)
}
```

**左边和右边采样**：
```rust
for i in 1..sample_count {
    let y = y1 + (y2 - y1) * i / sample_count;
    检查点 (x1, y) 和 (x2, y)
}
```

---

## 代码实现分析

### 完整代码结构

```rust
use crate::file::read_file;

// 1. 输入解析
fn parse_input(content: &str) -> Vec<(i64, i64)> {
    content
        .lines()
        .map(|line| {
            let (a, b) = line.split_once(",").unwrap();
            (a.trim().parse().unwrap(), b.trim().parse().unwrap())
        })
        .collect()
}

// 2. 计算矩形面积
fn bounding_area(p1: &(i64, i64), p2: &(i64, i64)) -> i64 {
    let dx = (p1.0 - p2.0).abs() + 1;
    let dy = (p1.1 - p2.1).abs() + 1;
    dx * dy
}

// 3. Part 1 解法
fn resolve_part1(points: &[(i64, i64)]) -> i64 {
    points
        .iter()
        .enumerate()
        .flat_map(|(i, p1)|
            points[i + 1..].iter()
                .map(|p2| bounding_area(p1, p2))
        )
        .max()
        .unwrap_or(0)
}

// 4. 点在多边形内检测
fn point_in_polygon(point: (i64, i64), polygon: &[(i64, i64)]) -> bool {
    // ... (详见上文)
}

// 5. 矩形在多边形内检测
fn rectangle_in_polygon(p1: (i64, i64), p2: (i64, i64), polygon: &[(i64, i64)]) -> bool {
    // ... (详见上文)
}

// 6. Part 2 解法
fn resolve_part2(points: &[(i64, i64)]) -> i64 {
    let mut max_area = 0;

    for i in 0..points.len() {
        for j in (i + 1)..points.len() {
            let p1 = points[i];
            let p2 = points[j];

            if rectangle_in_polygon(p1, p2, points) {
                let area = bounding_area(&p1, &p2);
                max_area = max_area.max(area);
            }
        }
    }

    max_area
}
```

### 关键函数解析

#### 1. `parse_input`
**功能**：将字符串输入转换为坐标数组

**示例**：
```
输入: "7,1\n11,1\n11,7"
输出: [(7, 1), (11, 1), (11, 7)]
```

#### 2. `bounding_area`
**功能**：计算两点确定的矩形面积

**示例**：
```
p1 = (2, 3), p2 = (7, 5)
dx = |2 - 7| + 1 = 6
dy = |3 - 5| + 1 = 3
area = 6 × 3 = 18
```

#### 3. `resolve_part1`
**功能**：遍历所有点对，找最大面积

**流程**：
```
enumerate(): 给每个点加上索引
  (0, (7,1)), (1, (11,1)), (2, (11,7)), ...

flat_map(): 对每个点，与后续所有点配对
  i=0, p1=(7,1):  计算与 (11,1), (11,7), ... 的面积
  i=1, p1=(11,1): 计算与 (11,7), (9,7), ... 的面积
  ...

max(): 找到最大值
```

#### 4. `point_in_polygon`
**功能**：判断点是否在多边形内

**关键点**：
- 先检查边界（顶点和边）
- 再用射线投射算法检查内部

#### 5. `rectangle_in_polygon`
**功能**：判断矩形是否完全在多边形内

**策略**：
- 先检查四个角（快速排除）
- 再采样边缘（精确验证）

#### 6. `resolve_part2`
**功能**：找到多边形内的最大矩形

**流程**：
```
对于每一对红色瓷砖:
    1. 检查矩形是否在多边形内
    2. 如果是，计算面积
    3. 更新最大值
```

---

## 复杂度分析

### Part 1

**时间复杂度**：O(n²)
- n 个点，枚举所有点对：C(n,2) = n(n-1)/2 ≈ O(n²)
- 每次面积计算：O(1)

**空间复杂度**：O(n)
- 存储输入点数组

**示例**：
- 8 个点：28 次比较
- 100 个点：4950 次比较
- 1000 个点：499500 次比较

### Part 2

**时间复杂度**：O(n² × m × k)
- n 个点，枚举所有点对：O(n²)
- 每对点检查矩形：
  - 检查 4 个角 + 边缘采样：O(m)，m 最多 100
  - 每次点在多边形检测：O(k)，k 是多边形边数 = n
- 总复杂度：O(n² × 100 × n) = O(n³)

**空间复杂度**：O(n)
- 存储多边形顶点

**优化点**：
1. **采样限制**：边缘采样最多 100 个点
2. **早期终止**：一旦发现点在外部，立即返回
3. **角点优先**：先检查四个角，快速排除大部分情况

**实际性能**：
```
测试数据（8个点）：< 1ms
真实数据（估计几百个点）：几秒内完成
```

---

## 示例完整演示

### 示例输入
```
7,1
11,1
11,7
9,7
9,5
2,5
2,3
7,3
```

### Part 1 求解过程

**所有点对及其面积**：
```
(7,1)  - (11,1):  5 × 1  = 5
(7,1)  - (11,7):  5 × 7  = 35 ✓
(7,1)  - (9,7):   3 × 7  = 21
(7,1)  - (9,5):   3 × 5  = 15
(7,1)  - (2,5):   6 × 5  = 30
(7,1)  - (2,3):   6 × 3  = 18
(7,1)  - (7,3):   1 × 3  = 3
(11,1) - (11,7):  1 × 7  = 7
(11,1) - (9,7):   3 × 7  = 21
(11,1) - (9,5):   3 × 5  = 15
(11,1) - (2,5):   10 × 5 = 50 ✓✓ (最大)
(11,1) - (2,3):   10 × 3 = 30
(11,1) - (7,3):   5 × 3  = 15
... (更多组合)
```

**最大面积**：50

### Part 2 求解过程

**多边形结构**：
```
(7,1) → (11,1) → (11,7) → (9,7) → (9,5) → (2,5) → (2,3) → (7,3) → (7,1)
```

**候选矩形**：
```
(9,5) - (2,3): 矩形 [2,9] × [3,5]
  检查角点：
    (2,3): 在顶点上 ✓
    (2,5): 在顶点上 ✓
    (9,3): 在多边形内？检查...✓
    (9,5): 在顶点上 ✓
  检查边缘采样：全部在内 ✓
  面积 = 8 × 3 = 24 ✓
```

**最大面积**：24

---

## 总结

### Part 1 关键点
1. 理解矩形面积计算（别忘了 +1）
2. 遍历所有点对，不重复不遗漏
3. 使用函数式编程简化代码

### Part 2 关键点
1. 理解多边形的形成（点按顺序连接）
2. 掌握射线投射算法
3. 采样检查矩形边缘（处理非凸情况）
4. 注意性能优化（采样数量��制）

### 学习建议
1. **先理解几何概念**：矩形、多边形、点在多边形内
2. **画图辅助理解**：手动画出示例，跟踪算法执行
3. **从简单到复杂**：先实现基本功能，再优化性能
4. **测试驱动**：用小示例验证每个函数

### 扩展思考
1. 如果多边形有洞怎么办？
2. 能否优化到 O(n² log n)？
3. 如果要找最大面积的三角形呢？

---

**希望这个文档能帮助你理解算法！有任何问题欢迎提问。**
